
def train(channel_input_dirs, hyperparameters):
    # retrieve the hyperparameters we set in notebook (with some defaults)
    
    batch_size = hyperparameters.get('batch_size', 55)
    epochs = hyperparameters.get('epochs', 100)
    learning_rate = hyperparameters.get('learning_rate', 0.1)
    momentum = hyperparameters.get('momentum', 0.9)
    wd = hyperparameters.get('wd', 0.0001)

    data_dir = channel_input_dirs['training']
    ctx=[mx.gpu(0)]
    
    train_data = gluon.data.DataLoader(
        gluon.data.vision.Cifar10(data_dir, train=True, transform=transforms.ToTensor()),
        batch_size=opt.batch_size, shuffle=True, last_batch='discard')

    val_data = gluon.data.DataLoader(
        gluon.data.vision.Cifar10(data_dir, train=False, transform=transforms.ToTensor()),
        batch_size=opt.batch_size, shuffle=False)    
    


    net = models.get_model('resnet34_v2', ctx=mx.gpu(), pretrained=False, classes=10)
    net.initialize(mx.init.Xavier(magnitude=2), ctx=ctx)
    
    trainer = gluon.Trainer(net.collect_params(), 'sgd',
                            optimizer_params={'learning_rate': learning_rate,
                                              'momentum': momentum,
                                              'wd': wd})
    metric = mx.metric.Accuracy()
    criterion = gluon.loss.SoftmaxCrossEntropyLoss()

    

    for epoch in range(epochs):
        train_data.reset()
        metric.reset()

        for i, (data, label) in enumerate(train_data):
            # Copy data to ctx if necessary
            data = data.as_in_context(ctx)
            label = label.as_in_context(ctx)
            
            outputs = []
            losses = []
            with ag.record():
                for x, y in zip(data, label):
                    z = net(x)
                    loss = criterion(z, y)
                    losses.append(loss)
                    outputs.append(z)
                for loss in losses:
                    loss.backward()
            trainer.step(batch.data[0].shape[0])
            metric.update(label, outputs)
            
        name, acc = metric.get()
        logging.info('[Epoch %d] training: %s=%f' % (epoch, name, acc))
        logging.info('[Epoch %d] time cost: %f' % (epoch, time.time() - tic))

        
        test_data.reset()
        test_metric = mx.metric.Accuracy()
        for i, batch in enumerate(test_data):
            data = gluon.utils.split_and_load(batch.data[0], ctx_list=ctx, batch_axis=0)
            label = gluon.utils.split_and_load(batch.label[0], ctx_list=ctx, batch_axis=0)
            outputs = []
            for x in data:
                outputs.append(net(x))
            test_metric.update(label, outputs)       
            
        name, val_acc = test_metric.get()
        logging.info('[Epoch %d] validation: %s=%f' % (epoch, name, val_acc))


    return net
